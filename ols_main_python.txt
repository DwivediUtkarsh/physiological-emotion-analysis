#===========================================================================================================
# class MyHandler(FileSystemEventHandler):
#     def on_created(self, event):
#         if event.is_directory:
#             print(f'No CSV file created: ')
#             return
#         elif event.event_type == 'created' and event.src_path.endswith('.csv'):
#             print(f'New CSV file created: {event.src_path}')
#             process_data(event.src_path)
#
# def process_data(file_path):
#     new_data = []
#     signals = pd.read_csv("signals_data.csv")
#     PS = np.asanyarray(signals)
#
#     folder_path = './csv_data'
#     #
#     # isExist = os.path.exists(folder_path)
#     # print(isExist)
#
#     # Step 2: List all CSV files in the folder and get their creation or modification times
#     csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
#     csv_files_with_paths = [os.path.join(folder_path, f) for f in csv_files]
#     file_times = {f: os.path.getmtime(os.path.join(folder_path, f)) for f in csv_files}
#
#     # Step 3: Find the file with the latest timestamp
#     latest_file = max(file_times, key=file_times.get)
#
#     # Step 4: Read the CSV file
#     latest_file_path = os.path.join(folder_path, latest_file)
#     annotate_time = pd.read_csv(latest_file_path)
#
#
#     # annotate_time = pd.read_csv("csv_data/data (1).csv")
#     df = annotate_time.iloc[-1]
#     video_id = df["videoID"]
#     start_time = df["time"]
#     if (df["videoID"] != 0):
#
#         if(df["videoID"] == 1):
#             actual_end_time = start_time + 177000
#         elif(df["videoID"] == 2):
#             actual_end_time = start_time +172000
#         elif (df["videoID"] == 3):
#             actual_end_time = start_time +118000
#         elif (df["videoID"] == 4):
#             actual_end_time = start_time +165000
#         elif (df["videoID"] == 5):
#             actual_end_time = start_time +145000
#         elif (df["videoID"] == 6):
#             actual_end_time = start_time +146000
#         elif (df["videoID"] == 7):
#             actual_end_time = start_time +198000
#         elif (df["videoID"] == 8):
#             actual_end_time = start_time +147000
#         print(start_time)
#
#
#         for i in range(start_time, actual_end_time, 5000):
#             new_data = []
#             start_time2 = i
#             end_time = start_time2 + 15000
#             print(start_time2)
#             print(end_time)
#
#             length_data = (len(PS))
#             for j in range(length_data):
#
#                 if ((start_time2 <= PS[j, 3]) & (end_time >= PS[j, 3])):
#                     new_data.append(PS[j])
#
#             new_df = pd.DataFrame(new_data)
#             new_df.rename(columns={0: 'Time_series'}, inplace=True)
#             new_df.rename(columns={1: 'GSR'}, inplace=True)
#             new_df.rename(columns={2: 'HR'}, inplace=True)
#             new_df.rename(columns={3: 'timestamp'}, inplace=True)
#             new_df.rename(columns={4: 'time2'}, inplace=True)
#             # new_df["subject"] = str(id)
#             # id = str(i)
#             new_df["video_id"] = video_id
#             new_df.to_csv("test/online_"+str(i)+".csv")
#
#             #read_file
#             filename = pd.read_csv("test/online_"+str(i)+".csv")
#             print("filename",filename)
#
#             # Calculate_change_point_score
#             from cal_change_point import get_change_point_scores
#             get_change_point_scores(filename,i, window_size=50)
#
#             ##calculate_physiological_difference
#             from cal_physiological_diff import get_signal_diff
#             get_signal_diff(filename, i)
#
#             ###Predict_opportune_moment
#             from model_prediction import get_model_prediction
#             final_feature = pd.read_csv("final2/windowdata.csv")
#             v_no = final_feature['video_id'].iloc[0]
#
#             if len(final_feature) > 3:
#                 index_values = final_feature.index[final_feature['Start_time'] == i].tolist()
#                 for k in range(len(index_values)):
#                     # Get the previous two rows for each index value
#                     current_index = index_values[k]
#                     if current_index > 3:
#                         previous_two_rows = final_feature.iloc[current_index - 3:current_index]
#                         # Print or use the resulting DataFrame as needed
#                         print(previous_two_rows)
#                     else:
#                         print("Not enough previous rows found for the condition.")
#
#                 test = pd.DataFrame(previous_two_rows)
#                 testX = test[['Score', 'valence_acc_video', 'arousal_acc_video', 'GSR_diff', 'HR_diff']]
#                 get_model_prediction(testX, i, v_no)
#
# # Set up the watchdog observer
# path_to_watch = "./csv_data"
# event_handler = MyHandler()
# observer = Observer()
# observer.schedule(event_handler, path=path_to_watch, recursive=False)
# observer.start()
#
# try:
#     while True:
#         time.sleep(10)
# except KeyboardInterrupt:
#     observer.stop()
#
# observer.join()